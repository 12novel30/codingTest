
## time = over/30m
- re3보다는 잘 풀었는데, 좀 더 연습하면 될 것 같다
- 경로수를 체크할 때는 이전 값 + 1 ... 메모

## info
1. 현 위치는 1,1 = 0,0
2. 출구는 n,m = n-1,m-1
3. 0(괴물)은 피해야하고
4. 1은 이동 가능 -> n-1, m-1까지 가야한다
5. 최소 경로의 길이 print

## Logic
- bfs
- 이동 경로 수: 이동하면서 각 칸에 표시
1. 방문 여부 & 인접 모두 maze로
    - 방문: 1->0
    - 인접: 상 하 좌 우 의 0인 모든 칸
        - maze를 벗어나면 패스
        - 괴물(1)이면 패스
2. maze의 0,0부터 모든 칸을 **bfs로 선회**
    - 현재 위치를 queue에 넣기
    - 현재 위치는 변경 x !!! -> 맨 처음은 0이 맞고, 이동하면 +1이기 때문.
    - 연결되어 있는 노드 중 non pass인 경우
        - queue.append
        - maze[nx][ny] = maze[x][y] + 1; 이전의 값에서 1을 증가시킨다
        - => 경로를 한 칸 증가시켰음을 의미